<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en"><head>
        <title>Encoding Real x86 Instructions</title>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
        <meta http-equiv="Expires" content="Wed, 31 Jan 2007 23:59:59 GMT">
    </head>
    <body>
	<hr>

    <h3>
        1. Encoding x86 Instructions
<a href="https://www-user.tu-chemnitz.de/~heha/viewchm.php/hs/x86.chm/x86.htm">(excerpt from)</a>
    </h3>
 <hr>
 <ul style="list-style-type:none;">
  <li>
    They don't call the x86 CPU a Complex Instruction Set Computer (CISC) for nothing!
  </li>
  <li>
    Although more complex instruction encodings exist, no one is going 
to challenge that the x86 has a complex instruction encoding:
    &nbsp;
	<br>
    &nbsp;
    <img src="Encoding%20Real%20x86%20Instructions_files/x86_instruction_encoding.png" alt="x86 Instruction Encoding">
  </li>
  <li>
    &nbsp;
    <img src="Encoding%20Real%20x86%20Instructions_files/x86_instruction_format.png" alt="The x86 instruction format">
  </li>
 </ul>

 <hr>


<a id="X77_0050_add_opcode"></a>


<h3> 5. x86 ADD Instruction Opcode </h3>
 <hr>

 <ul style="list-style-type:none;">
  <li>
    add opcode byte: 
  </li>
  <li>
    &nbsp;
    <img src="Encoding%20Real%20x86%20Instructions_files/x86_add_opcode.png" alt="x86 ADD Opcode">
  </li>
  <li>
    Bit number <strong>one</strong>, marked <strong>d</strong>, specifies the <strong>direction</strong> of the data transfer:
   <ul>
    <li>
      If <strong>d = 0</strong> then the destination operand is a memory location, e.g.,
      <pre>        add [ebx], al </pre>
    </li>
    <li>
      If <strong>d = 1</strong> then the destination operand is a register, e.g.,
      <pre>        add al, [ebx] </pre>
    </li>
    <li>
	  <strong>s = 0</strong> if adding 8-bit operands and <strong>s = 1</strong> for 32-bit operands.
	</li>
   </ul>
  </li>
 </ul>

 <hr>


<a id="X77_0060_mod_reg_r_m_byte"></a>


<h3> 6. Encoding x86 Instruction Operands, MOD-REG-R/M Byte </h3>
 <hr>
 <ul style="list-style-type:none;">
  <li>
   <p>
     The <span style="color: blue">MOD-REG-R/M</span> byte specifies
    <a href="http://www.c-jump.com/CIS77/images/x86_instruction_format.png" target="_blank">instruction</a>
    operands and their addressing mode:
   </p>
  </li>
 </ul>
     <table cellspacing="0" cellpadding="2" border="0">
         <tbody><tr>
             <td valign="top">
 <ul style="list-style-type:none;">
  <li>
   <p>
     &nbsp;
    <img src="Encoding%20Real%20x86%20Instructions_files/mod_reg_r_m_byte.png" alt="MOD-REG-R/M Byte">
   </p>
  </li>
 </ul>
 <ul style="list-style-type:none;">
  <li>
   <p>
     The <strong>MOD</strong> field specifies x86 addressing mode:
   </p>
   <p>
    &nbsp;
    <img src="Encoding%20Real%20x86%20Instructions_files/mod_meaning.png" alt="MOD Meaning">
   </p>
  </li>
 </ul>
 <ul style="list-style-type:none;">
  <li>
   <p>
     The <strong>REG</strong> field specifies source or destination <strong>register</strong>:
   </p>
   <p>
    &nbsp;
    <img src="Encoding%20Real%20x86%20Instructions_files/x86_register_encoding.png" alt="x86 register encoding">
   </p>
  </li>
 </ul>
             </td>
             <td valign="top">
 <ul style="list-style-type:none;">
  <li>
   <p>
     The <strong>R/M</strong> field, combined with <strong>MOD</strong>, specifies either
   </p>
   <ol>
    <li>
     <p>
       the second operand in a <strong>two</strong>-operand instruction, or
     </p>
    </li>
    <li>
     <p>
      the only operand in a <strong>single</strong>-operand instruction like <span style="color: blue">NOT</span> or <span style="color: blue">NEG</span>.
     </p>
    </li>
   </ol>
  </li>
  <li>
   <p>
    The <strong>d</strong> bit in the opcode determines which operand is the source, and which is the destination:
   </p>
   <ul style="list-style-type:none;">
    <li>
     <p>
       <strong>d=0: MOD R/M <tt>&lt;-</tt> REG</strong>, REG is the source
     </p>
    </li>
    <li>
     <p>
      <strong>d=1: REG <tt>&lt;-</tt> MOD R/M</strong>, REG is the destination
     </p>
    </li>
   </ul>
  </li>
 </ul>
             </td>
         </tr>
     </tbody></table>
 <ul style="list-style-type:none;">
  <li>
   <p>
    Since the processor accesses registers more quickly than it accesses
	memory, you can make your programs run faster by keeping the most-frequently
	used data in registers.
   </p>
   <p>
    For certain (often single-operand or immediate-operand) instructions, the <strong>REG</strong> field may contain an <em>opcode extension</em> rather than the register bits. The <strong>R/M</strong> field will specify the operand in such case.
   </p>
  </li>
 </ul>
<br> <br> <br>
 <hr>


<a id="X77_0090_addressing_modes"></a>
    <h3> 9. MOD R/M Byte and Addressing Modes </h3>
     <table cellspacing="0" cellpadding="2" border="1">
         <tbody><tr>
             <td valign="top">
 <ul style="list-style-type:none;">
  <li>
<pre>MOD R/M Addressing Mode
=== === ================================
 00 000 [ <span style="color: blue">eax</span> ]
 01 000 [ <span style="color: blue">eax</span> + <strong>disp8</strong> ]               (1)
 10 000 [ <span style="color: blue">eax</span> + <strong>disp32</strong> ]
 11 000 <span style="color: blue">register</span>  ( <span style="color: blue">al</span> / <span style="color: blue">ax</span> / <span style="color: blue">eax</span> )   (2)
 00 001 [ <span style="color: blue">ecx</span> ]
 01 001 [ <span style="color: blue">ecx</span> + <strong>disp8</strong> ]
 10 001 [ <span style="color: blue">ecx</span> + <strong>disp32</strong> ]
 11 001 <span style="color: blue">register</span>  ( <span style="color: blue">cl</span> / <span style="color: blue">cx</span> / <span style="color: blue">ecx</span> )
 00 010 [ <span style="color: blue">edx</span> ]
 01 010 [ <span style="color: blue">edx</span> + <strong>disp8</strong> ]
 10 010 [ <span style="color: blue">edx</span> + <strong>disp32</strong> ]
 11 010 <span style="color: blue">register</span>  ( <span style="color: blue">dl</span> / <span style="color: blue">dx</span> / <span style="color: blue">edx</span> )
 00 011 [ <span style="color: blue">ebx</span> ]
 01 011 [ <span style="color: blue">ebx</span> + <strong>disp8</strong> ]
 10 011 [ <span style="color: blue">ebx</span> + <strong>disp32</strong> ]
 11 011 <span style="color: blue">register</span>  ( <span style="color: blue">bl</span> / <span style="color: blue">bx</span> / <span style="color: blue">ebx</span> )
 00 100 <strong>SIB</strong>  Mode                     (3)
 01 100 <strong>SIB</strong>  +  <strong>disp8</strong>  Mode
 10 100 <strong>SIB</strong>  +  <strong>disp32</strong>  Mode
 11 100 <span style="color: blue">register</span>  ( <span style="color: blue">ah</span> / <span style="color: blue">sp</span> / <span style="color: blue">esp</span> )
 00 101 32-bit Displacement-Only Mode (4)
 01 101 [ <span style="color: blue">ebp</span> + <strong>disp8</strong> ]
 10 101 [ <span style="color: blue">ebp</span> + <strong>disp32</strong> ]
 11 101 <span style="color: blue">register</span>  ( <span style="color: blue">ch</span> / <span style="color: blue">bp</span> / <span style="color: blue">ebp</span> )
 00 110 [ <span style="color: blue">esi</span> ]
 01 110 [ <span style="color: blue">esi</span> + <strong>disp8</strong> ]
 10 110 [ <span style="color: blue">esi</span> + <strong>disp32</strong> ]
 11 110 <span style="color: blue">register</span>  ( <span style="color: blue">dh</span> / <span style="color: blue">si</span> / <span style="color: blue">esi</span> )
 00 111 [ <span style="color: blue">edi</span> ]
 01 111 [ <span style="color: blue">edi</span> + <strong>disp8</strong> ]
 10 111 [ <span style="color: blue">edi</span> + <strong>disp32</strong> ]
 11 111 <span style="color: blue">register</span>  ( <span style="color: blue">bh</span> / <span style="color: blue">di</span> / <span style="color: blue">edi</span> )
</pre>
  </li>
 </ul>
             </td>
             <td valign="top">
 <ul style="list-style-type:none;">
  <li>
   <p>
     &nbsp;
   </p>
  </li>
 </ul>
 <ol>
  <li>
   <p>
     Addressing modes with 8-bit displacement fall in the range -128..+127 and require only a single byte displacement after the
    <a href="http://www.c-jump.com/CIS77/images/x86_instruction_format.png" target="_blank">opcode</a>
    (Faster!)
   </p>
  </li>
  <li>
   <p>
    The size bit in the opcode specifies 8 or 32-bit register size. To select a 16-bit register requires a prefix byte.
   </p>
  </li>
  <li>
   <p>
    The so-called scaled indexed addressing modes, <strong>SIB</strong> = scaled index byte mode.
   </p>
  </li>
  <li>
   <p>
    Note that there is no [ <span style="color: blue">ebp</span> ] addressing. It's slot is occupied by the 32-bit <em>displacement only</em> addressing mode. Intel decided that programmers can use [ <span style="color: blue">ebp</span>+ <strong>disp8</strong> ] addressing mode instead, with its 8-bit displacement set equal to zero (instruction is a little longer, though.)
   </p>
  </li>
 </ol>
             </td>
         </tr>
     </tbody></table>

 <hr>


<a id="X77_0100_sib_byte_layout"></a>


    <h3>
        10. SIB (Scaled Index Byte) Layout
    </h3>
 <hr>
     <table cellspacing="0" cellpadding="2" border="0">
         <tbody>
		 <tr>
             <td valign="top">
 <ul>
  <li>
   <p>
    <em>Scaled indexed addressing mode</em> uses the second byte (namely, <strong>SIB</strong> byte) that follows the <strong>MOD-REG-R/M</strong> byte in the
    <a href="http://www.c-jump.com/CIS77/images/x86_instruction_format.png" target="_blank">instruction</a>
    format.
   </p>
  </li>
  <li>
   <p>
    The <strong>MOD</strong> field still specifies the displacement size of <strong>zero</strong>, <strong>one</strong>, or <strong>four</strong> bytes.
   </p>
   <ul style="list-style-type:none;">
    <li>
     <p>
       The <strong>MOD-REG-R/M</strong> and SIB bytes are complex, 
because Intel reused 16-bit addressing circuitry in the 32-bit mode, 
rather than simply abandoning the 16-bit format in the 32-bit mode.
     </p>
    </li>
    <li>
     <p>
      There are good hardware reasons for this, but the end result is a 
complex scheme for specifying addressing modes in the opcodes.
     </p>
    </li>
   </ul>
  </li>
 </ul>
             </td>
             <td valign="top">
 <ul style="list-style-type:none;">
  <li>
   <p>
     Scaled index byte layout:
   </p>
   <p>
    &nbsp;
    <img src="Encoding%20Real%20x86%20Instructions_files/sib_layout.png" alt="SIB, Scaled index byte layout">
   </p>
   <p>
    &nbsp;
    <img src="Encoding%20Real%20x86%20Instructions_files/sib_scaled_index.png" alt="SIB scaled index values">
   </p>
  </li>
 </ul>
  </td>
  </tr>

  <tr>
  <td valign="top">
    &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;
    <img src="Encoding%20Real%20x86%20Instructions_files/sib_index_register.png" alt="SIB index register encoding">
	</td><td>
    <img src="Encoding%20Real%20x86%20Instructions_files/sib_base_register.png" alt="SIB base register encoding">
  </td>
  </tr>

  </tbody></table>
 <hr>


<a id="X77_0110_scaled_indexed"></a>


    <h3>
        11. Scaled Indexed Addressing Mode
    </h3>
     <table cellspacing="0" cellpadding="2" border="1">
         <tbody><tr>
             <td valign="top">
 <ul style="list-style-type:none;">
  <li>
<pre>[ <span style="color: blue">reg32</span> + <span style="color: blue">eax</span>*<strong>n</strong> ] MOD = 00
[ <span style="color: blue">reg32</span> + <span style="color: blue">ebx</span>*<strong>n</strong> ] 
[ <span style="color: blue">reg32</span> + <span style="color: blue">ecx</span>*<strong>n</strong> ]
[ <span style="color: blue">reg32</span> + <span style="color: blue">edx</span>*<strong>n</strong> ]
[ <span style="color: blue">reg32</span> + <span style="color: blue">ebp</span>*<strong>n</strong> ]
[ <span style="color: blue">reg32</span> + <span style="color: blue">esi</span>*<strong>n</strong> ]
[ <span style="color: blue">reg32</span> + <span style="color: blue">edi</span>*<strong>n</strong> ]

[ <strong>disp</strong> + <span style="color: blue">reg8</span> + <span style="color: blue">eax</span>*<strong>n</strong> ] MOD = 01
[ <strong>disp</strong> + <span style="color: blue">reg8</span> + <span style="color: blue">ebx</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span style="color: blue">reg8</span> + <span style="color: blue">ecx</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span style="color: blue">reg8</span> + <span style="color: blue">edx</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span style="color: blue">reg8</span> + <span style="color: blue">ebp</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span style="color: blue">reg8</span> + <span style="color: blue">esi</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span style="color: blue">reg8</span> + <span style="color: blue">edi</span>*<strong>n</strong> ]

[ <strong>disp</strong> + <span style="color: blue">reg32</span> + <span style="color: blue">eax</span>*<strong>n</strong> ] MOD = 10
[ <strong>disp</strong> + <span style="color: blue">reg32</span> + <span style="color: blue">ebx</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span style="color: blue">reg32</span> + <span style="color: blue">ecx</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span style="color: blue">reg32</span> + <span style="color: blue">edx</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span style="color: blue">reg32</span> + <span style="color: blue">ebp</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span style="color: blue">reg32</span> + <span style="color: blue">esi</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span style="color: blue">reg32</span> + <span style="color: blue">edi</span>*<strong>n</strong> ]

[ <strong>disp</strong> + <span style="color: blue">eax</span>*<strong>n</strong> ] MOD = 00, and
[ <strong>disp</strong> + <span style="color: blue">ebx</span>*<strong>n</strong> ] BASE field = 101
[ <strong>disp</strong> + <span style="color: blue">ecx</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span style="color: blue">edx</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span style="color: blue">ebp</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span style="color: blue">esi</span>*<strong>n</strong> ]
[ <strong>disp</strong> + <span style="color: blue">edi</span>*<strong>n</strong> ]
</pre>
  </li>
 </ul>
             </td>
             <td valign="top">
 <ul style="list-style-type:none;">
  <li>
   <p>
     &nbsp;
   </p>
   <p>
    Note: <strong>n</strong> = <strong>1</strong>, <strong>2</strong>, <strong>4</strong>, or <strong>8</strong>.
   </p>
  </li>
  <li>
   <p>
    In each <strong>scaled indexed addressing mode</strong> the <strong>MOD</strong> field in <strong>MOD-REG-R/M</strong> byte specifies the <em>size of the displacement</em>. It can be zero, one, or four bytes:
   </p>
<pre>    MOD R/M  Addressing Mode
    --- ---  --------------------------- 
     00 100  <strong>SIB</strong>
     01 100  <strong>SIB</strong> + <strong>disp8</strong>
     10 100  <strong>SIB</strong> + <strong>disp32</strong>
</pre>
  </li>
  <li>
   <p>
    The <strong>Base</strong> and <strong>Index</strong> fields of the
    <a href="http://www.c-jump.com/CIS77/images/x86_instruction_format.png" target="_blank">SIB byte</a>
    select the base and index registers, respectively.
   </p>
  </li>
  <li>
   <p>
    Note that this addressing mode does not allow the use of the <strong>ESP</strong>
 register as an index register.
    Presumably, Intel left this particular mode undefined to provide the
 ability to extend the addressing modes in a future version of the CPU.
   </p>
  </li>
 </ul>
             </td>
         </tr>
     </tbody></table>

<br><br><br><br>

 <hr>




<a id="X77_0140_encoding_add_ecx_eax"></a>


    <h3>
        14. Encoding ADD ECX, EAX Instruction
    </h3>
 <hr>
 <ul style="list-style-type:none;">
  <li>
<pre>    add ecx, eax
</pre>
  </li>
 </ul>
 <ul style="list-style-type:none;">
  <li>
   <p>
     &nbsp;
    <img src="Encoding%20Real%20x86%20Instructions_files/encoding_add_ecx_eax.png" alt="Encoding ADD ECX, EAX Instruction">
   </p>
  </li>
  <li>
    Note that we could also encode <span style="color: blue">ADD</span> <strong>ECX</strong>, <strong>EAX</strong> using the bytes <strong>03 C8</strong>.
  </li>
 </ul>
 <hr>


<a id="X77_0150_encoding_add_edx_displacement"></a>


 <h3> 15. Encoding ADD EDX, Displacement Instruction </h3>

 <hr>
 <ul style="list-style-type:none;">
  <li>
     Encoding the <span style="color: blue">ADD</span> <strong>EDX</strong>, DISP Instruction:
     <pre>    add edx, [disp]</pre>
     <img src="Encoding%20Real%20x86%20Instructions_files/encoding_add_edx_disp.png" alt="Encoding the ADD EDX, DISP Instruction">
  </li>
 </ul>
<br> <br> <br> <br> <br> <br> <br>
 <hr>


<a id="X77_0160_encoding_add_edi_ebx"></a>


    <h3>
        16. Encoding ADD EDI, [EBX] Instruction
    </h3>
 <hr>
 <ul style="list-style-type:none;">
  <li>
   <p>
     Encoding the <span style="color: blue">ADD</span> <strong>EDI</strong>, [ <strong>EBX</strong> ] instruction:
   </p>
<pre>    add edi, [ebx]
    <img src="Encoding%20Real%20x86%20Instructions_files/encoding_add_edi_ebx.png" alt="Encoding the ADD EDI, [EBX] Instruction">
</pre>
  </li>
 </ul>
 <hr>



<a id="X77_0180_encoding_add_ebx_ebp_disp32"></a>


    <h3>
        18. Encoding ADD EBX, [ EBP + disp32 ] Instruction
    </h3>
 <hr>
 <ul style="list-style-type:none;">
  <li>
   <p>
     Encoding the <span style="color: blue">ADD</span> <strong>EBX</strong>, [ <strong>EBP</strong> + <strong>disp32</strong> ] instruction:
   </p>
<pre>    add ebx, [ ebp + disp32 ]
    <img src="Encoding%20Real%20x86%20Instructions_files/encoding_add_ebx_ebp_disp32.png" alt="Encoding the ADD EBX, [ EBP + disp32 ] Instruction">
</pre>
  </li>
 </ul>
<br> <br> <br> <br> <br> <br> <br> <br>
 <hr>


<a id="X77_0200_encoding_add_ecx_ebx_edi_4"></a>

 <h3> 20. Encoding ADD ECX, [ EBX + EDI*4 ] Instruction </h3>
 <hr>
 <ul style="list-style-type:none;">
  <li>
   <p>
     Encoding the <span style="color: blue">ADD</span> <strong>ECX</strong>, [ <strong>EBX</strong> + <strong>EDI</strong>*4 ] Instruction
   </p>
<pre>    add ecx, [ ebx + edi*4 ]
    <img src="Encoding%20Real%20x86%20Instructions_files/encoding_add_ecx_ebx_edi_4.png" alt="Encoding ADD ECX, [ EBX + EDI*4 ] Instruction">
</pre>
  </li>
 </ul>
 <hr>


<a id="X77_0210_encoding_add_immediate"></a>


 <h3> 21. Encoding ADD Immediate Instruction </h3>
 <hr>
     <table cellspacing="0" cellpadding="2" border="0">
         <tbody><tr>
             <td valign="top">
 <ul style="list-style-type:none;">
  <li>
   <p>
     <strong>MOD-REG-R/M</strong> and <strong>SIB</strong> bytes have no bit combinations to specify an immediate operand.
   </p>
  </li>
  <li>
   <p>
    Instead, x86 uses a entirely different
    <a href="http://www.c-jump.com/CIS77/images/x86_instruction_format.png" target="_blank">instruction format</a>
    to specify instruction with an immediate operand.
   </p>
  </li>
 </ul>
             </td>
             <td valign="top">
 <ul style="list-style-type:none;">
  <li>
   <p>
     Encoding x86 immediate operands:
   </p>
   <p>
    &nbsp;
    <img src="Encoding%20Real%20x86%20Instructions_files/encoding_immediate_operands.png" alt="Encoding Immediate Operands">
   </p>
  </li>
 </ul>
             </td>
         </tr>
     </tbody></table>
 <ol>
    There are three rules that apply:
  <li>
     If opcode high-order bit set to <strong>1</strong>, then <em>instruction has an immediate constant</em>.
  </li>
  <li>
    There is no direction bit in the opcode:
   <ul style="list-style-type:none;">
    <li>
      Indeed, you cannot specify a constant as a destination operand!
    </li>
    <li>
      Therefore, destination operand is always the location encoded in the <strong>MOD-R/M</strong> bits of the the <strong>MOD-REG-R/M</strong> byte.
    </li>
    <li>
      In place of the direction bit <strong>d</strong>, the opcode has a sign extension <strong>x</strong> bit instead:
     <ul>
      <li>
        For 8-bit operands, the CPU ignores <strong>x</strong> bit.
      </li>
      <li>
        For 16-bit and 32-bit operands, <strong>x</strong> bit specifies the size of the <span style="color: white; background-color: red">Constant</span> following at the end of the instruction:
       <ul>
        <li>
          If <strong>x</strong> bit contains <strong>zero</strong>, the <span style="color: white; background-color: red">Constant</span> is the same size as the operand (i.e., 16 or 32 bits).
        </li>
        <li>
          If <strong>x</strong> bit contains <strong>one</strong>, the <span style="color: white; background-color: red">Constant</span> is a <span style="color: blue">signed</span> 8-bit value, and the CPU sign-extends this value to the appropriate size before adding it to the operand.
        </li>
       </ul>
      </li>
      <li>
        This little <strong>x</strong> trick often makes programs shorter, because adding small-value constants to 16 or 32 bit operands is very common.
      </li>
     </ul>
    </li>
   </ul>
  </li>
  <li>
   <p>
    The third difference between the <span style="color: blue">ADD</span>-immediate and the standard <span style="color: blue">ADD</span> instruction is the meaning of the <strong>REG</strong> field in the <strong>MOD-REG-R/M</strong> byte:
   </p>
   <ul>
    <li>
      Since the instruction implies that
     <ul>
      <li>
        the source operand is a constant, and
      </li>
      <li>
        <strong>MOD-R/M</strong> fields specify the destination operand,
      </li>
     </ul>
      the instruction does not need to use the <strong>REG</strong> field to specify an operand.
    </li>
    <li>
      Instead, the x86 CPU uses these three bits as an <strong>opcode extension</strong>.
    </li>
    <li>
      For the <span style="color: blue">ADD</span>-immediate instruction the <strong>REG</strong> bits must contain zero.
    </li>
    <li>
      Other bit patterns would correspond to a different instruction.
    </li>
   </ul>
  </li>
 </ol>
 <ul style="list-style-type:none;">
  <li>
   <p>
     Note that when adding a constant to a memory location, the 
displacement (if any) immediately precedes the immediate (constant) 
value in the opcode sequence.
   </p>
  </li>
 </ul>
 <hr>





<a id="X77_0280_design_considerations"></a>


    <h3>
        28. ISA Design Considerations
    </h3>
 <hr>
 <ul>
  <li>
   <p>
    Instruction set architecture design that can stand the test of time is a true intellectual challenge.
   </p>
  </li>
  <li>
   <p>
    It takes several compromises between space and efficiency to assign opcodes and encode instruction formats.
   </p>
  </li>
  <li>
   <p>
    Today people are using Intel x86 instruction set for purposes never intended by original designers.
   </p>
  </li>
  <li>
   <p>
    Extending the CPU is a very difficult task.
   </p>
  </li>
  <li>
   <p>
    The instruction set can become <em>extremely complex</em>.
   </p>
  </li>
  <li>
   <p>
    If x86 CPU was designed <em>from scratch</em> today, it would have a totally different ISA!
   </p>
  </li>
  <li>
   <p>
    Software developers usually don't have a problem adapting to a new architecture when writing new software...
   </p>
   <ul style="list-style-type:none;">
    <li>
     <p>
       ...but they are very resistant to moving existing software from one platform to another.
     </p>
    </li>
   </ul>
  </li>
  <li>
   <p>
    This is the primary reason the Intel x86 platform remains so popular to this day.
   </p>
  </li>
 </ul>
 <hr>


</body></html>